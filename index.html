<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: GTIRB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v0.1.1</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">GTIRB </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="gtirb"></a></p>
<p>The GrammaTech Intermediate Representation for Binaries (GTIRB) is a machine code analysis and rewriting data structure. It is intended to facilitate the communication of binary IR between programs performing binary disassembly, analysis, transformation, and pretty printing. GTIRB is modeled on LLVM-IR, and seeks to serve a similar functionality of encouraging communication and interoperability between tools.</p>
<p>The remainder of this file describes various aspects of GTIRB:</p><ul>
<li><a href="#structure">Structure</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
<h2>Structure</h2>
<p><a class="anchor" id="structure"></a></p>
<p>GTIRB has the following structure: </p><pre class="fragment">    -------Aux Data
   /    /
  /    /   ----DataObject
IR    /   /----Section
  \  /   /-----Symbols
  Modules------SymbolicExpressions
         \-----ImageByteMap
          -----CFG
               / \
           Edges Blocks
</pre><h3>IR</h3>
<p><a class="anchor" id="ir"></a></p>
<p>An instance of GTIRB may include multiple modules (<code>Module</code>) which represent loadable objects such as executables or libraries. Each module holds information such as symbols (<code>Symbol</code>), data (<code>DataObject</code>), and an inter-procedural control flow graph (<code>CFG</code>). The CFG consists of basic blocks (<code>Block</code>) and control flow edges between these blocks. Each datum and each block holds a range refering to the bytes in the <code>ImageByteMap</code>. Each symbol holds a pointer to the block or datum it references.</p>
<h3>Instructions</h3>
<p><a class="anchor" id="instructions"></a></p>
<p>GTIRB explicitly does NOT represent instructions or instruction semantics but does provide symbolic operand information and access to the bytes. There are many <em>intermediate language*s (IL)s for representation of instruction semantics (e.g., <a href="https://github.com/BinaryAnalysisPlatform/bap">BAP</a>'s <a href="https://github.com/BinaryAnalysisPlatform/bil/releases/download/v0.1/bil.pdf">BIL</a>, <a href="http://angr.io">Angr</a>'s <a href="https://github.com/angr/pyvex">Vex</a>, or <a href="https://www.nsa.gov/resources/everyone/ghidra/">Ghidra</a>'s P-code). GTIRB works with these or any other IL by storing instructions generally and efficiently as *raw machine-code bytes</em> and separately storing the symbolic and control flow information. The popular <a href="https://www.capstone-engine.org">Capstone</a>/<a href="https://www.keystone-engine.org">Keystone</a> decoder/encoder provide an excellent option to read and write instructions from/to GTIRB's machine-code byte representation without committing to any particular semantic IL. By supporting multiple ILs and separate storage of analysis results in auxiliary data tables GTIRB enables collaboration between independent binary analysis and rewriting teams and tools.</p>
<h3>Auxiliary Data</h3>
<p><a class="anchor" id="auxiliary-data"></a></p>
<p>GTIRB provides for the sharing of additional information, e.g. analysis results, in the form of <code>AuxData</code> objects. These can store maps and vectors of basic GTIRB types in a portable way. This repository will describe the anticipated structure for very common types of auxiliary data such as function boundary information, type information, or results of common analyses.</p>
<h3>UUIDs</h3>
<p><a class="anchor" id="uuids"></a></p>
<p>Every element of GTIRB (namely: modules (<code>Module</code>), symbols (<code>Symbol</code>), blocks (<code>Block</code>), and instructions (<code>InstructionRef</code>) has a universally unique identifier (UUID). UUIDs allow both first-class IR components and AuxData tables to reference elements of the IR.</p>
<h2>Building</h2>
<p><a class="anchor" id="building"></a></p>
<p>GTIRB should successfully build in 64-bits with GCC, Clang, and Visual Studio compilers supporting at least C++17. GTIRB uses CMake which must be installed.</p>
<div class="fragment"><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ../path/to/gtirb</div><div class="line">make -j</div><div class="line"># Run the test suite.</div><div class="line">&lt;a name=&quot;run-the-test-suite.&quot; id=&quot;run-the-test-suite.&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">./bin/TestGTIRB</div></div><!-- fragment --><p>The gtirb library will be located in <code>lib/libgtirb.so</code> in the build directory.</p>
<p>Note that you may need to explicitly specify the path to the vcpkg installation when executing CMake. By default, GTIRB looks in C:\vcpkg\scripts\buildsystems\vcpkg.cmake to find the CMake support for the toolchain, but a different path can be specified by passing </p><pre class="fragment">-DCMAKE_TOOLCHAIN_FILE="C:\path\to\vcpkg\scripts\buildsystems\vcpkg.cmake"
</pre><p>when executing the CMake command above.</p>
<h3>Requirements</h3>
<p><a class="anchor" id="requirements"></a></p>
<p>The GTIRB build process automatically downloads all external requirements during build. However to <em>install</em> GTIRB, the following requirements should be installed separately.</p>
<ul>
<li>Protobuf versions 3.1 (or later once we disable warnings in the protobuf build)</li>
<li>Boost version 1.67.0 or later.</li>
</ul>
<h2>Usage</h2>
<p><a class="anchor" id="usage"></a></p>
<p>GTIRB is designed to be serialized using <a href="https://developers.google.com/protocol-buffers/">Google's protocol buffers</a> (i.e., <a href="https://github.com/google/protobuf/wiki">protobuf</a>), enabling <a href="#using-serialized-gtirb-data">easy and efficient use from any programming language</a>.</p>
<p>GTIRB may also be <a href="#using-the-c++-api">used as a C++ library</a> implementing an efficient data structure suitable for use by binary analysis and rewriting applications.</p>
<ul>
<li><a href="#using-serialized-gtirb-data">Using Serialized GTIRB Data</a></li>
<li><a href="#using-the-c++-library">Using the C++ Library</a></li>
</ul>
<h3>Using Serialized GTIRB Data</h3>
<p><a class="anchor" id="using-serialized-gtirb-data"></a></p>
<p>The serialized <a href="https://github.com/google/protobuf/wiki">protobuf</a> data produced by GTIRB allows for exploration and manipulation in the language of your choice. The <a href="https://developers.google.com/protocol-buffers/">Google protocol buffers</a> homepage lists the languages in which protocol buffers can be used directly; users of other languages can convert the protobuf-formatted data to JSON format and then use the JSON data in their applications. In the future we intend to define a standard JSON schema for GTIRB.</p>
<p>Directory <code>gtirb/src/proto</code> contains the protocol buffer message type definitions for GTIRB. You can inspect these <code>.proto</code> files to determine the structure of the various GTIRB message types. The top-level message type is <code>IR</code>.</p>
<p>For more details, see <a class="el" href="md__p_r_o_t_o_b_u_f.html">Using Serialized GTIRB Data</a></p>
<h3>Using the C++ Library</h3>
<p><a class="anchor" id="using-the-c++-library"></a></p>
<p>We have provided several C++ examples in directory <code>gtirb/doc/examples</code>. See the <a href="examples.html">Examples tab</a> for more information.</p>
<p>The remainder of this section provides examples walking through common tasks using the GTIRB C++ library API.</p>
<ul>
<li><a href="#populating-the-ir">Populating the IR</a></li>
<li><a href="#querying-the-ir">Querying the IR</a></li>
<li><a href="#serialization">Serialization</a></li>
</ul>
<h4>Populating the IR</h4>
<p><a class="anchor" id="populating-the-ir"></a></p>
<p>GTIRB objects are created within a <code>Context</code> object. Freeing the <code>Context</code> will also destroy all the objects within it.</p>
<div class="fragment"><div class="line">Context C;</div><div class="line">IR&amp; ir = *IR::Create(C);</div></div><!-- fragment --><p>Every IR holds a set of modules.</p>
<div class="fragment"><div class="line">ir.addModule(Module::Create(C));</div><div class="line">Module&amp; module = ir.modules()[0];</div></div><!-- fragment --><p>Addresses are represented by a distinct type which can be explicitly converted to and from <code>uint64_t</code>.</p>
<div class="fragment"><div class="line">Addr textSectionAddress(1328);</div></div><!-- fragment --><p>Create some sections: </p><div class="fragment"><div class="line">module.addSection(Section::Create(C, <span class="stringliteral">&quot;.text&quot;</span>, textSectionAddress, 466));</div><div class="line">module.addSection(</div><div class="line">    Section::Create(C, <span class="stringliteral">&quot;.data&quot;</span>, textSectionAddress + 466, 2048));</div></div><!-- fragment --><p>Create some data objects. These only define the layout and do not directly store any data.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>* data1 = DataObject::Create(C, Addr(2608), 6);</div><div class="line"><span class="keyword">auto</span>* data2 = DataObject::Create(C, Addr(2614), 2);</div><div class="line">module.addData(data1);</div><div class="line">module.addData(data2);</div></div><!-- fragment --><p>The actual data is stored in the module's ImageByteMap:</p>
<div class="fragment"><div class="line">ImageByteMap&amp; byteMap = module.getImageByteMap();</div><div class="line">byteMap.setAddrMinMax({Addr(2608), Addr(2616)});</div><div class="line">std::array&lt;uint8_t, 8&gt; bytes{1, 0, 2, 0, 115, 116, 114, 108};</div><div class="line">byteMap.setData(Addr(2608), bytes);</div></div><!-- fragment --><p>Symbols associate a name with an object in the <code>IR</code>, such as a <code>DataObject</code> or <code>Block</code>. They can optionally store an address instead.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> data = module.data();</div><div class="line">module.addSymbol(Symbol::Create(C,</div><div class="line">                                data1,      <span class="comment">// referent</span></div><div class="line">                                <span class="stringliteral">&quot;data1&quot;</span>,    <span class="comment">// name</span></div><div class="line">                                Symbol::StorageKind::Extern));</div><div class="line">module.addSymbol(Symbol::Create(C, data2, <span class="stringliteral">&quot;data2&quot;</span>,</div><div class="line">                                Symbol::StorageKind::Extern));</div></div><!-- fragment --><p>GTIRB can store multiple symbols with the same address or referent.</p>
<div class="fragment"><div class="line">module.addSymbol(Symbol::Create(C, data2, <span class="stringliteral">&quot;duplicate&quot;</span>,</div><div class="line">                                Symbol::StorageKind::Local));</div><div class="line">module.addSymbol(Symbol::Create(C, Addr(2608), <span class="stringliteral">&quot;alias&quot;</span>))</div></div><!-- fragment --><p>Basic blocks are stored in an interprocedural CFG. Like <code>DataObjects</code>, <code>Blocks</code> reference data in the <code>ImageByteMap</code> but do not directly hold any data themselves. GTIRB does not directly represent instructions.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; cfg = module.getCFG();</div><div class="line"><span class="keyword">auto</span>* b1 = <a class="code" href="classgtirb_1_1_block.html#a697d606f21392b1ec5f64f64fd39538e">emplaceBlock</a>(cfg, C, Addr(466), 6);</div><div class="line"><span class="keyword">auto</span>* b2 = <a class="code" href="classgtirb_1_1_block.html#a697d606f21392b1ec5f64f64fd39538e">emplaceBlock</a>(cfg, C, Addr(472), 8);</div></div><!-- fragment --><p>The <code>CFG</code> can be populated with edges to denote control flow. Or edges can be omitted and the <code>CFG</code> used simply as a container for <code>Blocks</code>..</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> edge1 add_edge(vertex1, vertex2, mainModule.getCFG()).first;</div></div><!-- fragment --><p>Edges can have boolean or numeric labels:</p>
<div class="fragment"><div class="line">module.getCFG()[edge1] = <span class="keyword">true</span>;</div><div class="line">module.getCFG()[edge2] = 1;</div></div><!-- fragment --><p>Information on symbolic operands and data is indexed by address:</p>
<div class="fragment"><div class="line">Symbol* dataSym = &amp;*module.findSymbols(Addr(2614)).begin();</div><div class="line">module.addSymbolicExpression(Addr(472), SymAddrConst{0, dataSym});</div></div><!-- fragment --><p>Finally, auxiliary data can be used to store additional data at the IR level. An <code>AuxData</code> object can store integers, strings, basic GTIRB types such as <code>Addr</code> and <code>UUID</code>, and tuples or containers over these types.</p>
<div class="fragment"><div class="line">ir.addAuxData(<span class="stringliteral">&quot;addrTable&quot;</span>, std::vector&lt;Addr&gt;({Addr(1), Addr(2), Addr(3)}));</div><div class="line">ir.addAuxData(<span class="stringliteral">&quot;stringMap&quot;</span>, std::map&lt;std::string, std::string&gt;(</div><div class="line">                             {{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;str1&quot;</span>}, {<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;str2&quot;</span>}}));</div></div><!-- fragment --><h4>Querying the IR</h4>
<p><a class="anchor" id="querying-the-ir"></a></p>
<p>Symbols can be looked up by address or name. Any number of symbols can share an address or name, so be prepared to deal with multiple results.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> syms = module.findSymbols(Addr(2614));</div><div class="line"><span class="keyword">auto</span> it = syms.begin();</div><div class="line">Symbol&amp; sym1 = *it++;</div><div class="line">assert(sym1.getName() == <span class="stringliteral">&quot;data2&quot;</span>);</div><div class="line">assert((*it++).getName() == <span class="stringliteral">&quot;duplicate&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span>&amp; sym2 = *module.findSymbols(<span class="stringliteral">&quot;data1&quot;</span>).begin();</div><div class="line">assert(sym2.getAddress() == Addr(2608));</div></div><!-- fragment --><p>Use a symbol's referent (either an InstructionRef or DataObject) to get more information about the object to which the symbol points.</p>
<div class="fragment"><div class="line">DataObject* referent = sym1.getReferent&lt;DataObject&gt;();</div><div class="line">assert(referent);</div><div class="line">assert(referent-&gt;getAddress() == Addr(2614));</div><div class="line">assert(referent-&gt;getSize() == 2);</div></div><!-- fragment --><p>Alternatively, DataObjects can be looked up by an address contained within the object. Any number of objects may overlap and contain an address, so be prepared to deal with multiple results.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> objs = module.findData(Addr(2610));</div><div class="line">assert(objs.size() == 1);</div><div class="line">assert(objs.begin()-&gt;getAddress() == Addr(2608));</div></div><!-- fragment --><p>The CFG uses <a href="https://www.boost.org/doc/libs/1_67_0/libs/graph/doc/">boost::graph</a>. GTIRB also provides a convenience function for iterating over blocks:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; b : <a class="code" href="group___c_f_g___g_r_o_u_p.html#ga5039337a49b78d1fe67d47a61f8fcba9">blocks</a>(cfg)) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Block: &quot;</span> &lt;&lt; uint64_t(b.getAddress()) &lt;&lt; <span class="stringliteral">&quot;..&quot;</span></div><div class="line">            &lt;&lt; uint64_t(<a class="code" href="classgtirb_1_1_addr.html#a94b7fd934eae65c03b284cc50d352030">addressLimit</a>(b)) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><code>Blocks</code> contain a <code>vertex_descriptor</code> which is used to look up corresponding information in the <code>CFG</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [edgeDescriptor, exists] = edge(b1-&gt;getVertex(), b2-&gt;getVertex(), cfg);</div><div class="line">assert(exists);</div></div><!-- fragment --><p><code>edge_descriptors</code> can be used to look up labels and the source/target blocks:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> edgeRange = edges(cfg);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = edgeRange.first; it != edgeRange.second; it++) {</div><div class="line">  <span class="keyword">auto</span> e = *it;</div><div class="line">  <span class="keyword">auto</span> v1 = source(e, cfg);</div><div class="line">  <span class="keyword">auto</span> v2 = target(e, cfg);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Edge: &quot;</span> &lt;&lt; uint64_t(cfg[v1]-&gt;getAddress()) &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span></div><div class="line">            &lt;&lt; uint64_t(cfg[v2]-&gt;getAddress());</div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span>* b = std::get_if&lt;bool&gt;(&amp;cfg[e])) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; *b;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Data have to be resolved to the correct type with the <code>get()</code> method before use. This will return null if the wrong type is requested.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> addrTable = ir.getAuxData(<span class="stringliteral">&quot;addrTable&quot;</span>)-&gt;get&lt;std::vector&lt;Addr&gt;&gt;();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> addr : *addrTable) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Addr: &quot;</span> &lt;&lt; uint64_t(addr) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">auto</span>* stringMap =</div><div class="line">    ir.getAuxData(<span class="stringliteral">&quot;stringMap&quot;</span>)-&gt;get&lt;std::map&lt;std::string, std::string&gt;&gt;();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : *stringMap) {</div><div class="line">  std::cout &lt;&lt; p.first &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><h4>Serialization</h4>
<p><a class="anchor" id="serialization"></a></p>
<p>Serialize IR to a file:</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;path/to/file&quot;</span>);</div><div class="line">ir.save(out);</div></div><!-- fragment --><p>Deserialize from a file:</p>
<div class="fragment"><div class="line">std::ifstream in(<span class="stringliteral">&quot;path/to/file&quot;</span>);</div><div class="line">IR&amp; newIR = *IR::load(C, in);</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
